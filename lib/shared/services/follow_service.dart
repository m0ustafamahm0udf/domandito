import 'package:domandito/core/utils/shared_prefrences.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:domandito/core/utils/extentions.dart';

import 'package:flutter/material.dart';
import 'package:domandito/shared/models/follow_model.dart';
import 'package:domandito/core/constants/app_constants.dart';

class FollowService {
  static final SupabaseClient _supabase = Supabase.instance.client;

  static const String followTable = "follows";
  static const String usersTable = "users";

  static final Map<String, bool> _isProcessing = {};

  /// ---------------------------------------------------------------------------
  /// üîÅ Toggle Follow (Follow / Unfollow)
  /// ---------------------------------------------------------------------------
  static Future<bool> toggleFollow({
    required FollowUser me, // ÿ£ŸÜÿß
    required FollowUser targetUser, // ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑŸÑŸä Ÿáÿ™ÿßÿ®ÿπŸá
    required BuildContext context,
  }) async {
    if (!MySharedPreferences.isLoggedIn) {
      return false;
    }
    if (_isProcessing[targetUser.id] == true) return false;
    _isProcessing[targetUser.id] = true;

    bool isNowFollowing = false;

    try {
      // 1. Check if follow exists
      final existingFollow = await _supabase
          .from(followTable)
          .select()
          .eq('follower_id', me.id)
          .eq('following_id', targetUser.id)
          .maybeSingle();

      if (existingFollow != null) {
        // -------------------------------------------------------------------
        // ‚ùå Unfollow (Delete)
        // -------------------------------------------------------------------
        await _supabase
            .from(followTable)
            .delete()
            .eq('id', existingFollow['id']);

        isNowFollowing = false;
      } else {
        // -------------------------------------------------------------------
        // ‚ù§Ô∏è Follow (Insert)
        // -------------------------------------------------------------------
        // Create model just to get params if needed, or build map directly
        final follow = FollowModel(
          id: '', // Generated by DB
          createdAt: DateTime.now(),
          me: me,
          targetUser: targetUser,
        );

        await _supabase.from(followTable).insert(follow.toJson());

        isNowFollowing = true;
      }
    } catch (e) {
      debugPrint("Follow error: $e");
      AppConstance().showInfoToast(
        context,
        msg: !context.isCurrentLanguageAr()
            ? "Something went wrong, try again"
            : "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ÿå ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ",
      );
      // Return previous state (if we failed, assume no change effectively?
      // Or we can't determine easily so just return false/true based on intent?
      // The calling code updates UI based on return.
      // If error, we should probably throw or handle better, but for now maintaining signature.)
    } finally {
      _isProcessing[targetUser.id] = false;
    }

    return isNowFollowing;
  }

  /// ---------------------------------------------------------------------------
  /// ‚ùì Check if I follow this user
  /// ---------------------------------------------------------------------------
  static Future<bool> isFollowing({
    required String myId,
    required String targetUserId,
  }) async {
    try {
      final count = await _supabase
          .from(followTable)
          .count()
          .eq('follower_id', myId)
          .eq('following_id', targetUserId);

      return count > 0;
    } catch (e) {
      return false;
    }
  }

  /// ---------------------------------------------------------------------------
  /// üóëÔ∏è Force Unfollow (Used when blocking)
  /// ---------------------------------------------------------------------------
  static Future<void> forceUnfollow({
    required String followerId,
    required String followingId,
  }) async {
    debugPrint(
      "ForceUnfollow: Atomic Delete. Follower=$followerId, Following=$followingId",
    );
    try {
      // Use dedicated RPC to bypass any RLS/Permission issues
      // Function: force_delete_follow(p_follower_id, p_following_id)
      await _supabase.rpc(
        'force_delete_follow',
        params: {'p_follower_id': followerId, 'p_following_id': followingId},
      );

      debugPrint("ForceUnfollow: Delete command executed.");
    } catch (e) {
      debugPrint("Force Unfollow Error: $e");
    }
  }

  // NOTE: Manual counter updates removed in favor of Database Triggers.
  // See 'setup_follow_counters_trigger.sql'
}
