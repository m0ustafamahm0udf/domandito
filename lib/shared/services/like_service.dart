import 'package:domandito/core/constants/app_constants.dart';
import 'package:domandito/core/services/notifications/send_message_notification.dart';
import 'package:domandito/core/utils/extentions.dart';

import 'package:domandito/core/utils/utils.dart';
import 'package:domandito/modules/notifications/repositories/notifications_repository.dart';
import 'package:domandito/shared/models/like_model.dart';
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class LikeService {
  static final SupabaseClient _supabase = Supabase.instance.client;

  // Ù„Ù…Ù†Ø¹ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ø³Ø±ÙŠØ¹
  static final Map<String, bool> _isProcessing = {};

  /// Toggle like Ù…Ø¹ (Supabase logic + Firestore Counter)
  static Future<bool> toggleLike({
    required String questionId,
    required LikeUser user,
    required BuildContext context,
  }) async {
    // Ù„Ùˆ ÙÙŠÙ‡ Ø¹Ù…Ù„ÙŠØ© Ø´ØºØ§Ù„Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¯Ù„ÙˆÙ‚ØªÙŠ
    if (_isProcessing[questionId] == true) return false;

    _isProcessing[questionId] = true;

    bool result = false;

    try {
      // 1. Check if like exists in Supabase
      final likeQuery = await _supabase
          .from('likes')
          .select()
          .eq('question_id', questionId)
          .eq('user_id', user.id)
          .limit(1);

      if (likeQuery.isNotEmpty) {
        // Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ â†’ Ø­Ø°Ù Ø§Ù„Ù„Ø§ÙŠÙƒ
        final likeId = likeQuery.first['id'];
        await _supabase.from('likes').delete().eq('id', likeId);

        result = false; // Ø¯Ù„ÙˆÙ‚ØªÙŠ Ù…Ø´ Ù„Ø§ÛŒÚ©
      } else {
        // Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯ â†’ Ø¥Ø¶Ø§ÙØ© now
        DateTime now = await getNetworkTime() ?? DateTime.now();

        final like = LikeModel(
          id: '', // Generated by Supabase
          questionId: questionId,
          createdAt: now,
          user: user,
        );

        await _supabase.from('likes').insert(like.toJson());

        result = true; // Ø¯Ù„ÙˆÙ‚ØªÙŠ Ù„Ø§ÛŒÚ© (DB operation successful)

        // Fetch question owner to notify them
        // Fetch question owner to notify them
        final questionResponse = await _supabase
            .from('questions')
            .select('receiver_id, receiver:receiver_id(token)')
            .eq('id', questionId)
            .maybeSingle();

        if (questionResponse != null) {
          final receiverId = questionResponse['receiver_id'] as String;
          final receiverToken =
              questionResponse['receiver']['token'] as String?;

          // if (receiverId != user.id) {
          // Don't notify self
          // Send persistent notification and push notification in parallel
          await Future.wait([
            if (receiverToken != null)
              SendMessageNotificationWithHTTPv1().send2(
                type: AppConstance.like,
                urll: '',
                toToken: receiverToken,
                message: AppConstance.liked,
                title: 'Domandito',
                id: questionId,
              ),
            NotificationsRepository().sendNotification(
              senderId: user.id,
              receiverId: receiverId,
              type: AppConstance.like,
              entityId: questionId,
              title: 'Domandito',
              body: AppConstance.liked,
            ),
          ]);
          // }
        }
      }
    } catch (e) {
      debugPrint("Error toggling like: $e");
      AppConstance().showInfoToast(
        context,
        msg: !context.isCurrentLanguageAr()
            ? "Something went wrong, try again"
            : "Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰",
      );
    } finally {
      _isProcessing[questionId] = false;
    }

    return result;
  }

  /// ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ù…Ù„ Ù„Ø§ÙŠÙƒ Ø¨Ø§Ù„ÙØ¹Ù„
  static Future<bool> isLiked({
    required String questionId,
    required String userId,
  }) async {
    try {
      final snap = await _supabase
          .from('likes')
          .select()
          .eq('question_id', questionId)
          .eq('user_id', userId)
          .limit(1);

      return snap.isNotEmpty;
    } catch (e) {
      debugPrint("Error checking if liked: $e");
      return false;
    }
  }

  /// ğŸš€ Batch Check Likes (Improved Performance)
  static Future<Set<String>> getLikedQuestions({
    required List<String> questionIds,
    required String userId,
  }) async {
    if (questionIds.isEmpty) return {};

    try {
      final snap = await _supabase
          .from('likes')
          .select('question_id')
          .eq('user_id', userId)
          .inFilter('question_id', questionIds);

      final data = snap as List<dynamic>;
      return data.map((e) => e['question_id'] as String).toSet();
    } catch (e) {
      debugPrint("Error batch checking likes: $e");
      return {};
    }
  }
}
